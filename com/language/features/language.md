### java是解释性语言
    解释性语言：编译后的代码不能直接被机器执行，需要解释器来执行；
    编译性语言：编译后的代码已经是二进制的了，可以直接被机器执行；
    
    强类型机制；
    异常处理；
    垃圾自动回收；


### jdk和jre
    JDK：
        给JAVA开发人员使用的JAVA开发工具包；
        JDK = JRE + 开发工具集；
    JRE：
        JAVA运行环境，想要运行一个开发好的JAVA程序，只安装JRE就行了；
        JRE = JVM + JAVA SE标准类库；



### java执行流程分析
![img.png](picture%2Fimg.png)
```
编译：
    有了.java源文件，通过编译器将其编译成JVM可以识别的字节码.class文件；
    在该源文件目录下，通过 javac hello.java 编译工具对hello.java文件进行编译（编译类型的错误：语法错误、编码错误等）；
    如果程序没有错误，会在该目录下生成一个hello.class文件，该文件是字节码文件，也是可以执行的java程序；
运行：
    通过运行工具java.exe对字节码文件进行执行，本质就是.class装载到jvm机执行；
```
***生成的clss文件位置如下***
![img_1.png](picture%2Fimg_1.png)

### JAVA开发细节
	1.JAVA源文件是以 .java 为扩展名的，源文件的基本组成部分是类；
	2.JAVA的执行入口是main方法，有固定的书写格式：public void main(String[] args){...}；
	3.JAVA区分大小写，print和PRINT不是一个意思；
	4.JAVA的方法必须有分号；
	5.一个源文件（.java文件）中最多只能有一个public类，其他类的个数不限；
	6.文件名必须按public类名命名，否则会报错；
	7.在java源文件中，只要有一个类，编译后就会生成一个同名的.class文件；
	8.可以将main方法写在非public类中，然后指定运行非public类，就是非public的main方法；
	9.可以public和其他类中都写main方法，这样不会报错，并且指定执行哪个类都可以；

### JAVA API文档链接
	java语言提供了大量的基础类，因此oracle公司也为这些基础类提供了相应的API文档；
	https://www.matools.com/

### JAVA类的组织形式
![img_2.png](picture%2Fimg_2.png)
![img_3.png](picture%2Fimg_3.png)


### 内存泄漏和内存溢出
    内存泄漏是指程序在运行时没有正确释放已分配的内存，导致已分配的内存无法再被使用，最终耗尽系统内存。

    发生原因：
    程序申请了内存（例如，使用 malloc 或 new 等分配内存），但没有在不再需要时释放（例如，使用 free 或 delete）。
    或者，在程序中创建了多个引用或指针指向已分配的内存，但没有正确管理这些指针，导致无法释放内存。
    
    后果：
    内存泄漏会导致系统的可用内存逐渐减少，长时间运行的程序（如服务器或后台进程）可能会占用越来越多的内存，最终导致系统变慢或崩溃。
    即使操作系统分配了足够的物理内存，内存泄漏会使得这些内存无法回收和重复使用
    
    如何避免：
    每次使用动态内存分配后，确保在合适的时候释放内存。
    使用智能指针（如 C++ 的 std::unique_ptr 和 std::shared_ptr）或垃圾回收机制来自动管理内存。
    
    内存溢出
    内存溢出是指程序尝试访问超过其分配的内存空间，通常表现为数组越界或栈溢出等情况，导致程序崩溃或出现不可预料的行为。

    发生原因：
    栈溢出：通常由于递归调用过深或局部变量过多，超出了栈的容量。
    
        void recursive_function() {
            int arr[1000]; // 每次递归都会分配 1000 个整数的数组
            recursive_function(); // 无限递归，导致栈内存溢出
        }
        
        int main() {
            recursive_function();
            return 0;
        }

    堆溢出：如果程序动态分配内存时没有考虑到分配大小，导致堆内存被溢出。
    数组越界：访问数组时超出了数组的边界，导致程序写入无效或不应访问的内存地址。

        int main() {
            int arr[5];
            arr[10] = 100;  // 数组越界写入，内存溢出
            printf("%d", arr[10]);
            return 0;
        }
        
    后果：
    程序崩溃或者产生未定义行为，导致数据丢失、内存损坏或者安全漏洞。
    程序可能会出现崩溃、数据错误或安全风险（如缓冲区溢出攻击）。
    
    如何避免：
    栈溢出：避免递归深度过深，确保递归有合适的终止条件。
    堆溢出：合理分配堆内存，避免过大的内存请求。
    数组越界：访问数组时，确保下标不越界，使用现代编程语言的边界检查功能，或者使用容器（如 C++ 的 std::vector）来动态管理数组大小。

### 垃圾回收机制
```
参考：https://blog.csdn.net/weixin_53975556/article/details/125916780
Java 的垃圾回收机制（GC）是自动管理内存的一种方式，它的目的是释放不再使用的对象占用的内存空间。垃圾回收器会定期检查和回收无用对象（即不再被引用的对象），从而防止内存泄漏和溢出。

1. 垃圾回收的工作原理
垃圾回收的核心概念是：在 Java 中，当一个对象没有任何活动的引用时，它就不再能被使用了，称为 "不可达对象"。垃圾回收器会定期检测这些对象并回收它们所占用的内存。

主要步骤：
标记：垃圾回收器首先遍历所有活动的对象，标记出那些没有被引用的对象（即不可达对象）。
清理/回收：然后，它会回收那些标记为不可达的对象所占用的内存空间，释放不再使用的内存。
压缩（可选）：有些垃圾回收器还会将剩余的对象压缩到内存的低地址区域，避免内存碎片的发生。

2. 垃圾回收的主要算法
分代收集算法（Generational Collection）
Java 的垃圾回收机制主要基于 分代收集算法，它将堆内存划分为不同的区域（或称代），每个区域负责不同生命周期的对象。对象会随着时间的推移从年轻代（Young Generation）移动到老年代（Old Generation）。
分代垃圾回收算法的核心思想是，大部分对象在创建后不久就会变得不可达，因此可以频繁地回收年轻代中的对象，而较少的长寿命对象会移到老年代，进行较少频繁的回收。

3. Java 内存区域与分代模型
Java 堆内存被分为多个区域，每个区域负责不同生命周期的对象。
    3.1 年轻代（Young Generation）
    年轻代包含新创建的对象。它包含以下几个部分：
    
    Eden 空间：存放新创建的对象。
    Survivor 空间（S0 和 S1）：存放经过一次垃圾回收后仍然存活的对象。通常只有两个 Survivor 空间（S0 和 S1），交替使用。
    对象会在年轻代之间来回移动，直到它们成为长期存活的对象并晋升到老年代。
    
    3.2 老年代（Old Generation）
    老年代存储存活时间较长的对象。通常只有在年轻代的对象经过多次垃圾回收仍然存活时，它们才会被晋升到老年代。垃圾回收的频率较低。
    
    3.3 元空间（Metaspace）
    元空间用于存储类的元数据（如类定义、方法等）。Java 8 引入了 元空间（Metaspace）来取代之前的永久代（PermGen）。与堆内存不同，元空间不在堆中，通常是系统内存的一部分。

4.垃圾回收器（GC）种类
Java 提供了几种不同的垃圾回收器，每种回收器有不同的性能特点，适合不同类型的应用。
    4.1 串行垃圾回收器（Serial Garbage Collector）
    单线程执行所有垃圾回收工作。
    适用于单核 CPU 和小型应用。
    性能较差，因为停顿时间较长。
    使用：-XX:+UseSerialGC
    
    4.2 并行垃圾回收器（Parallel Garbage Collector）
    多线程执行垃圾回收。
    适用于多核 CPU 和 CPU 密集型应用。
    提供较短的垃圾回收时间，但可能会有较长的停顿时间。
    使用：-XX:+UseParallelGC
    
    4.3 并行老年代垃圾回收器（Parallel Old Garbage Collector）
    用于老年代的并行回收，与并行垃圾回收器一起使用。
    提供多线程支持，减少了老年代垃圾回收的时间。
    使用：-XX:+UseParallelOldGC
    
    4.4 CMS 垃圾回收器（Concurrent Mark-Sweep Garbage Collector）
    基于标记-清除算法的垃圾回收器，减少停顿时间。
    与应用程序并发工作，适用于对响应时间要求较高的应用。
    使用：-XX:+UseConcMarkSweepGC
    
    4.5 G1 垃圾回收器（Garbage First Garbage Collector）
    G1 是为了大内存的应用程序设计的垃圾回收器，能够预测和控制停顿时间。
    它将堆分为多个区域，优先回收垃圾最多的区域，减少停顿时间。
    使用：-XX:+UseG1GC
   
5. 垃圾回收的优化
内存分配优化：合理配置 JVM 内存大小（如 -Xms 和 -Xmx）以避免频繁的垃圾回收。
选择合适的垃圾回收器：根据应用的特点选择合适的垃圾回收器。例如，响应时间敏感的应用可以选择 CMS 或 G1 垃圾回收器。
监控和调优：定期监控 JVM 的垃圾回收日志，分析垃圾回收的效果，并根据需求进行调优。可以使用 -XX:+PrintGCDetails 来打印垃圾回收日志。

6. 总结
垃圾回收 是自动管理内存的一种方式，它能够回收不再使用的对象所占用的内存，避免内存泄漏。
垃圾回收的核心机制 是通过标记、清理、整理和复制的方式来回收不再使用的对象。
分代收集算法 是 Java 的垃圾回收机制的基础，它将堆分为年轻代和老年代，不同的对象会在不同的代中进行垃圾回收。
GC 优化 需要根据应用的特点选择合适的垃圾回收器，并通过监控和调整来优化性能。
```
[Person.java](code%2FPerson.java)

